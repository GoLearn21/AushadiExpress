############################ PATCH — WIRE OCR → STOCK + REMEMBER CAMERA #####################################

A  backend/schema.sql (add if missing)
---------------------------------------------------------------
-- products may come from OCR, so make name unique & mfr optional
ALTER TABLE products ADD COLUMN IF NOT EXISTS mfr TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS products_name_uq ON products(name);

-- receiving_items already created; add stock table if you don't have it
CREATE TABLE IF NOT EXISTS stock(
  id TEXT PRIMARY KEY,
  productId TEXT REFERENCES products(id),
  batchNumber TEXT,
  quantity INT,
  expiryDate TEXT,
  mrp REAL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP
);

B  utils/invoiceParser.ts  (very naïve line-splitter)
----------------------------------------------------
export interface Line{ name:string, batch:string, qty:number, exp:string, mrp:number }
export function parseInvoice(txt:string):Line[]{
  return txt.split(/\n/).map(l=>l.trim()).filter(l=>/qty/i.test(l)).map(l=>{
     const m=l.match(/^(.*?)\s+([A-Z0-9]{4,})\s+.*?\s+([0-9]{1,3})\s+([0-9]{2}\/[0-9]{2})\s+([\d.]+)/i);
     if(!m) return null;
     return {name:m[1].replace(/\s+/g,' '), batch:m[2], qty:+m[3], exp:`20${m[4]}`, mrp:+m[5]};
  }).filter(Boolean) as Line[];
}

C  backend/routes/stock.ts (new)
--------------------------------
import express from 'express';
import db from '../db';
export const stockRouter=express.Router();

stockRouter.post('/bulk', async(req,res)=>{
  const rows=req.body as {name:string,batch:string,qty:number,exp:string,mrp:number}[];
  for(const r of rows){
     let prod = db.prepare('SELECT * FROM products WHERE name=?').get(r.name);
     if(!prod){
        const id='prod-'+Date.now()+Math.random().toString(36).slice(2,6);
        db.prepare('INSERT INTO products(id,name) VALUES(?,?)').run(id,r.name);
        prod={id};
     }
     const sid='stock-'+Date.now()+Math.random().toString(36).slice(2,6);
     db.prepare(`INSERT INTO stock(id,productId,batchNumber,quantity,expiryDate,mrp)
                 VALUES(?,?,?,?,?,?)`)
       .run(sid,prod.id,r.batch,r.qty,r.exp,r.mrp);
  }
  console.log('STOCK-UPSERT', rows.length);
  res.status(201).json({ok:true, rows:rows.length});
});

export default stockRouter;

↳ Mount in `backend/index.ts`:

```ts
import stockRouter from './routes/stock';
app.use('/api/stock', stockRouter);
D services/cameraService.ts (wire OCR → backend)
import { parseInvoice } from '../utils/invoiceParser';
...
async function runOcrAndStore(invId:string, uri:string){
const txt = await TesseractOcr.recognize(uri,'LANG_ENGLISH');
console.log('INVOICE-OCR',txt.slice(0,80)+'...');
const rows=parseInvoice(txt);
if(rows.length){
await fetch('/api/stock/bulk',{method:'POST',headers:{'Content-Type':'application/json'},
body:JSON.stringify(rows)});
}
}

E remember camera permission (services/capability.ts)
export async function ensureCameraAllowed():Promise<boolean>{
const cached=localStorage.getItem('cam-ok');
if(cached==='1') return true;
const res = await Camera.requestCameraPermissionsAsync();
if(res.status==='granted') localStorage.setItem('cam-ok','1');
return res.status==='granted';
}
-- use ensureCameraAllowed() instead of plain check in camera-permission-modal

F invalidate React-Query caches after /stock/bulk
In useCapture() hook (or wherever you await capture), add:

ts
Copy code
await queryClient.invalidateQueries(['products']);
await queryClient.invalidateQueries(['stock']);
G UI feedback
Inside persistMeta after the fetch('/api/stock/bulk'...) resolves, show toast
{title:'Stock updated', description:\${rows.length} items added from invoice`}`.

#########################